# slice

## 底层结构
```
type slice struct {
	array unsafe.Pointer	//指向底层数组的指针
	len int			//切片长度
	cap int			//切片容量
}

详见:src/runtime/slice.go

```
- 指向底层数组的指针
```
前面已经提到，切片实际是对数组的一层封装。这个指针便是记录其底层数组的地址，也正是切片开始的位置。
```
- 切片长度
```
len表示切片的长度，即切片中现存有效元素的个数，它不能超过切片的容量。可以通过len()函数获取切片长度。
```
- 切片容量
```
cap表示切片的容量，即切片能存储元素的多少，通常是从切片的起始元素到底层数组的最后一个元素间的元素个数，当切片容量不足时，便会触发slice扩容。可以通过cap()函数获取切片容量。
```

## 切片定义
```
var a []int					//nil切片，和nil相等，一般用来表示一个不存在的切片
var b []int{}				//空切片，和nil不相等，一般用来表示一个空的集合
var c []int{1, 2, 3}		//有3个元素的切片，len和cap都为3
var d = c[:2]				//有2个元素的切片，len为2，cap为3
var e = c[:2:cap(c)]		//有2个元素的切片，len为2，cap为3
var f = c[:0]				//有0个元素的切片，len为0，cap为3
var g = make([]int, 3)		//创建一个切片，len和cap均为3
var h = make([]int, 3, 6)	//创建一个切片，len为3，cap为5
var i = make([]int, 0, 3)	//创建一个切片，len为0，cap为3 
```

## 切片截取
```
a[x:y]  左闭右开  x -> y-1
```

## 切片迭代
```
//使用一个值接收range, 则得到的是切片的下标
for i := range months {
	fmt.Println(i)		//返回下标 0 1 ... 12
}
//使用两个值接收range，则得到的是下标和对应的值
for i, v := range months {
	fmt.Println(i, v) 	//返回下标0 1 ... 12 和 值 "" "January" ... "December"
}
```

## 切片拷贝
```
使用copy内置函数拷贝两个切片时，会将源切片的数据逐个拷贝到目的切片指向的数组中，拷贝数量取两个切片的最小值。

例如长度为10的切片拷贝到长度为5的切片时，将拷贝5个元素。也就是说，拷贝过程中不会发生扩容。

copy函数有返回值，它返回实际上复制的元素个数，这个值就是两个slice长度的较小值。
```

## 切片扩容

### 追加元素
- **尾部追加元素(1/N)**

```
var a []int
a = append(a, 1)					// 追加一个元素
a = append(a, 1, 2, 3)				// 追加多个元素
a = append(a, []int{1, 2, 3}...)	// 追加一个切片，注意追加切片时后面要加...
```

- **首部插入元素(1/N)**

```
a = append([]int{0}, a...)			// 在开头添加一个元素
a = append([]int{1, 2, 3}, a...)	// 在开头添加一个切片
```

- **中间插入元素(1/N)**

    - **append**

    ```
    a = append(a[:i], append([]int{x}, a[i:]...)...)		//在第i个位置上插入x
    a = append(a[:i], append([]int{1, 2, 3}, a[i:]...)...)	//在第i个位置上插入切片
    ```

    - **append + copy**

    ```
    //中间插入一个元素
    a = append(a, 0)			//切片扩展一个空间
    copy(a[i+1:], a[i:])		//a[i:]向后移动一个位置
    a[i] = x					//设置新添加的元素
    //中间插入多个元素
    a = append(a, x...)			//为x切片扩展足够的空间
    copy(a[i+len(x):], a[i:])	//a[i:]向后移动len(x)个位置
    copy(a[i:], x)				//复制新添加的切片
    ```
### 删除元素
```
a = []int{1, 2, 3}
//删除尾部元素
a = a[:len(a) - 1]				//删除尾部一个元素
a = a[:len(a) - N]				//删除尾部N个元素
//删除头部元素
a = [1:]						//删除开头1个元素
a = [N:]						//删除开头N个元素
//删除中间元素
a = append(a[:i], a[i+1:]...)	//删除中间一个元素
a = append(a[:i], a[i+N:]...)	//删除中间N个元素
```

### 扩容
```
扩容操作只关心容量，会把原slice的数据拷贝至新slice中，追加数据由append在扩容后完成。
```

- **扩容容量的选择遵循以下基本规则**

```
如果原slice的容量小于1024，则新slice的容量将扩大为原来的2倍；
如果原slice的容量大于1024，则新的slice的容量将扩大为原来的1.25倍；
```

## 切片陷阱

- **无法做比较**
```
切片和切片无法做比较
切片可以和nil做比较
```

- **空切片和nil切片**
    - 空切片和nil切片是不同的
        - nil切片中，切片的指针指向的是空地址，其长度和容量都为零。nil切片和nil相等。
        - 空切片，切片的指针指向了一个地址，但其长度和容量也为0，和nil不相等，通常用来表示一个空的集合。
    ```
    var s []int				// s == nil
    var s = nil				// s == nil
    var s = []int{nil}			// s == nil
    var s = []int{}		 	// s != nil
    s := make([]int,0)  		// s != nil
    ```

- **使用range进行切片迭代**

    - 当使用range进行切片迭代时，range创建了每个元素的副本，而不是直接返回对该元素的引用。如果使用该值变量的地址作为每个元素的指针，就会造成错误。

    ```
    func main() {
	    a := []int{1, 2, 3, 4, 5}

	    for i, v := range a {
		    fmt.Printf("Value: %d, v-addr: %X, Elem-addr: %X",v, &v, &a[i])
        }
    }

    //output
    
        Value: 1, v-addr: C0000AA058, Elem-addr: C0000CC030
        Value: 2, v-addr: C0000AA058, Elem-addr: C0000CC038
        Value: 3, v-addr: C0000AA058, Elem-addr: C0000CC040
        Value: 4, v-addr: C0000AA058, Elem-addr: C0000CC048
        Value: 5, v-addr: C0000AA058, Elem-addr: C0000CC050
    ```
- **切片扩容引发的问题**
    - **切片使用append追加元素后无法保证追加后的切片是否和原切片是同一地址，也无法保证指针指向底层的数组是否是同一地址**

- **append函数误用**

    - **使用append函数时，需要考虑append返回的切片是否跟原切片共享底层的数组。**
    ```
    //示例来源:Go专家编程
    func AppendDemo() {
    	x := make([]int, 0, 10)
    	x = append(x, 1, 2, 3)
    	y := append(x, 4)
    	z := append(x, 5)
    	fmt.Println(x)
    	fmt.Println(y)
    	fmt.Println(z)
    }
    
    //output
    [1 2 3]
    [1 2 3 5]
    [1 2 3 5]
    ```
    - 一般情况下，使用append函数追加新的元素时，都会用原切片变量接收返回值来获得更新

- **函数传参**
    - 代码
        ```
        package main

        import "fmt"
        
        func main(){
            a := []int{1, 2, 3}   			//长度为3，容量为3
            b := make([]int, 1, 10)     	//长度为1，容量为10
            test(a,b)				
           	fmt.Println("main a =", a)
            fmt.Println("main b =", b)		
        }
        
        func test(a,b []int){
            a = append(a, 4)				//引发扩容，此时返回的a是一个新的切片
            b = append(b, 2)				//没有引发扩容，仍然是原切片
            a[0] = 3						//改变a切片元素
            b[0] = 3						//改变b切片元素
            fmt.Println("test a =", a)		//打印函数内的a切片
            fmt.Println("test b =", b)		//打印函数内的b切片
        }
        
        //output
        test a = [3 2 3 4]
        test b = [3 2]
        main a = [1 2 3]
        main b = [3]
        ```

    - 理论分析
        - 当我们将一个切片作为函数参数传递给函数的时候，采用的是值传递，因此我们传递给函数的参数其实是上面这个切片三元组的值拷贝。当我们对切片结构中的指针进行值拷贝的时候，得到的指针还是指向了同一个底层数组。因此我们通过指针对底层数组的值进行修改，从而修改了切片的值。

        - 但是，当我们以值传递的方式传递上面的结构体的时候，同时也是传递了len和cap的值拷贝，因为这两个成员并不是指针，因此，当我们从函数返回的时候，外层切片结构体的len和cap这两个成员并没有改变。

        - 所以当我们传递切片给函数的时候，并且在被调函数中通过append操作向切片中增加了值，但是当函数返回的时候，我们看到的切片的值还是没有发生变化，其实底层数组的值是已经改变了的（如果没有触发扩容的话），但是由于长度len没有发生改变，所以我们看到的切片的值也没有发生改变。

    - 题目再分析

        - a切片作为参数传至test函数中，在test中向a切片追加一个元素后，此时触发扩容机制，返回的切片已经不再是原切片，而是一个新的切片。后续对a切片中的第一个元素进行修改也是对新切片进行修改，对老切片不会产生任何影响。

        - 所以，最终在主函数中a切片仍然为[1 2 3]，而在test函数中a切片变成了[3 2 3 4]。

        - b切片作为参数传至test函数中，在test中向b切片追加一个元素后，不会触发扩容机制，返回的仍然是原切片，所以在后续对b切片的修改都是在原切片中进行的修改。故在test函数中b切片为[3 2]。但是在主函数中确为[3]，可以看出在test中对切片进行修改确实反应到主函数中了，但是由于其len和cap没有改变，len仍为1，所以最终就只输出切片中的第一个元素[3]，但其底层数组的值其实已经改变了。
    